<!DOCTYPE html>
<html>
<head>
    <title>360Photo Point Setting Tool</title>
    <style>
        body.sidebar-hidden #sidebar {
            display: none;
        }
        #sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 250px;
            background: #f8f8f8;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            transition: transform 0.3s;
            z-index: 100;
            padding: 10px;
        }
        #toggleSidebarBtn {
            position: fixed;
            left: 10px;
            top: 10px;
            z-index: 101;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        #pdf-container {
            margin: 20px;
            margin-left: 270px; /* room for sidebar */
        }
        body.sidebar-hidden #pdf-container {
            margin-left: 20px;
        }
        .page-container { 
            position: relative; 
            margin: 10px 0; 
            border: 1px solid #ccc;
        }
        .annotation-dot {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #ff4444;
            border-radius: 50%;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .annotation-dot:hover {
            transform: scale(1.1);
        }
        #toolbar {
            margin: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .mode-active {
            background-color: #4CAF50;
            color: white;
        }
        #pageIndicator {
            position: fixed;
            right: 30px;
            top: 30px;
            background: #333;
            color: #fff;
            padding: 5px 15px;
            border-radius: 4px;
            z-index: 200;
            opacity: 0.85;
            font-size: 16px;
        }
        #pdfPageList {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #pdfPageList li {
            cursor: pointer;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }
        #pdfPageList li:hover {
            background: #e0e0e0;
        }
    </style>
</head>
<body>
    <button id="toggleSidebarBtn" onclick="toggleSidebar()">â˜°</button>
    <div id="sidebar">
        <h3>PDF Pages</h3>
        <ul id="pdfPageList"></ul>
    </div>
    <div id="toolbar">
        <input type="file" id="pdfInput" accept="application/pdf" multiple>
        <button id="addModeBtn" onclick="toggleAddMode()">Set Point</button>
        <button id="moveModeBtn" onclick="toggleMoveMode()">Move</button>
    </div>
    <div id="pdf-container"></div>
    <div id="pageIndicator">Page -</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
    <script>
        let pdfFiles = [];
        let annotations = [];
        let currentAnnotationId = 1;
        let currentMode = 'none'; // 'add' / 'move' / 'none'
        let draggedElement = null;

        pdfjsLib.GlobalWorkerOptions.workerSrc = 
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js';

        document.getElementById('pdfInput').addEventListener('change', handleFileUpload);

        function toggleSidebar() {
            document.body.classList.toggle('sidebar-hidden');
        }

        function handleFileUpload(e) {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                if (!pdfFiles.find(f => f.name === file.name)) {
                    pdfFiles.push(file);
                    renderPDF(file);
                }
            });
        }

        async function renderPDF(file) {
            const reader = new FileReader();
            reader.onload = async function() {
                const pdf = await pdfjsLib.getDocument(reader.result).promise;
                file.numPages = pdf.numPages;
                const container = document.getElementById('pdf-container');
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1.5 });
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'page-container';
                    pageContainer.style.width = `${viewport.width}px`;
                    pageContainer.dataset.key = `${file.name}-${i}`;
                    
                    await page.render({ canvasContext: context, viewport }).promise;
                    
                    pageContainer.appendChild(canvas);
                    container.appendChild(pageContainer);
                    
                    loadAnnotations(pageContainer);
                    setupPageInteractions(pageContainer);
                }
                updatePdfPageList();
                updatePageIndicator();
            };
            reader.readAsArrayBuffer(file);
        }

        function setupPageInteractions(container) {
            // Double-click to add annotation (desktop only)
            container.addEventListener('dblclick', function(e) {
                if (currentMode !== 'add') return;
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createAnnotation(container, x, y);
            });

            // Mouse move for drag
            container.addEventListener('mousemove', function(e) {
                if (!draggedElement) return;
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                draggedElement.style.left = `${x - 12}px`;
                draggedElement.style.top = `${y - 12}px`;
            });

            // Mouse up to end drag
            container.addEventListener('mouseup', () => {
                if (draggedElement) {
                    const annotation = annotations.find(
                        a => a.id === parseInt(draggedElement.dataset.id)
                    );
                    annotation.x = parseFloat(draggedElement.style.left) + 12;
                    annotation.y = parseFloat(draggedElement.style.top) + 12;
                    draggedElement = null;
                }
            });

            // Touch move for drag
            container.addEventListener('touchmove', function(e) {
                if (!draggedElement) return;
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const x = e.touches[0].clientX - rect.left;
                const y = e.touches[0].clientY - rect.top;
                draggedElement.style.left = `${x - 12}px`;
                draggedElement.style.top = `${y - 12}px`;
            }, { passive: false });

            // Touch end to end drag
            container.addEventListener('touchend', function(e) {
                if (draggedElement) {
                    const annotation = annotations.find(
                        a => a.id === parseInt(draggedElement.dataset.id)
                    );
                    annotation.x = parseFloat(draggedElement.style.left) + 12;
                    annotation.y = parseFloat(draggedElement.style.top) + 12;
                    draggedElement = null;
                }
            });
        }

        function createAnnotation(container, x, y) {
            const annotation = {
                id: currentAnnotationId++,
                key: container.dataset.key,
                x,
                y,
                number: annotations.length + 1
            };
            annotations.push(annotation);
            updateNumbering();
            drawAnnotation(container, annotation);
        }

        function drawAnnotation(container, annotation) {
            const dot = document.createElement('div');
            dot.className = 'annotation-dot';
            dot.style.left = `${annotation.x - 12}px`;
            dot.style.top = `${annotation.y - 12}px`;
            dot.textContent = annotation.number;
            dot.dataset.id = annotation.id;

            // Mouse drag
            dot.addEventListener('mousedown', (e) => {
                if (currentMode === 'move') {
                    draggedElement = dot;
                }
            });

            // Touch drag (long press to start)
            let touchTimer = null;
            dot.addEventListener('touchstart', (e) => {
                if (currentMode !== 'move') return;
                e.preventDefault();
                touchTimer = setTimeout(() => {
                    draggedElement = dot;
                }, 500);
            }, { passive: false });

            dot.addEventListener('touchend', (e) => {
                clearTimeout(touchTimer);
                touchTimer = null;
            });

            // Click to delete (only in set-point mode)
            dot.addEventListener('click', function(e) {
                if (currentMode === 'move') return;
                e.stopPropagation();
                handleAnnotationClick(this);
            });

            container.appendChild(dot);
        }

        function handleAnnotationClick(element) {
            const annotationId = parseInt(element.dataset.id);
            if (confirm('Delete this point?')) {
                annotations = annotations.filter(a => a.id !== annotationId);
                element.remove();
                updateNumbering();
                redrawAllAnnotations();
            }
        }

        function toggleAddMode() {
            currentMode = currentMode === 'add' ? 'none' : 'add';
            document.getElementById('addModeBtn').classList.toggle('mode-active');
            document.body.style.cursor = currentMode === 'add' ? 'crosshair' : 'default';
        }

        function toggleMoveMode() {
            currentMode = currentMode === 'move' ? 'none' : 'move';
            document.getElementById('moveModeBtn').classList.toggle('mode-active');
            document.body.style.cursor = currentMode === 'move' ? 'move' : 'default';
        }

        function updateNumbering() {
            annotations.sort((a, b) => a.id - b.id);
            annotations.forEach((ann, index) => {
                ann.number = index + 1;
            });
        }

        function redrawAllAnnotations() {
            document.querySelectorAll('.page-container').forEach(container => {
                container.querySelectorAll('.annotation-dot').forEach(dot => dot.remove());
                const key = container.dataset.key;
                annotations
                    .filter(ann => ann.key === key)
                    .forEach(ann => drawAnnotation(container, ann));
            });
        }

        function loadAnnotations(container) {
            const key = container.dataset.key;
            annotations
                .filter(ann => ann.key === key)
                .forEach(ann => drawAnnotation(container, ann));
        }

        // Sidebar page list and navigation
        function updatePdfPageList() {
            const list = document.getElementById('pdfPageList');
            list.innerHTML = '';
            pdfFiles.forEach(file => {
                for (let i = 1; i <= (file.numPages || 0); i++) {
                    const li = document.createElement('li');
                    li.textContent = `${file.name} - Page ${i}`;
                    li.onclick = () => scrollToPage(`${file.name}-${i}`);
                    list.appendChild(li);
                }
            });
        }

        function scrollToPage(key) {
            const container = document.querySelector(`.page-container[data-key="${key}"]`);
            if (container) container.scrollIntoView({ behavior: 'smooth' });
        }

        // Page indicator
        window.addEventListener('scroll', updatePageIndicator);

        function updatePageIndicator() {
            const containers = Array.from(document.querySelectorAll('.page-container'));
            let current = null;
            let minDiff = Infinity;
            containers.forEach(container => {
                const rect = container.getBoundingClientRect();
                const diff = Math.abs(rect.top - 80);
                if (diff < minDiff && rect.bottom > 0) {
                    minDiff = diff;
                    current = container;
                }
            });
            if (current) {
                const [fileName, pageNum] = current.dataset.key.split('-');
                document.getElementById('pageIndicator').textContent = `Page ${pageNum}`;
            } else {
                document.getElementById('pageIndicator').textContent = 'Page -';
            }
        }
    </script>
</body>
</html>
